package main;

import java.util.ArrayList;

import entity.Entity;

public class CollisionChecker {
    GamePanel gp;
	
	public CollisionChecker(GamePanel gp) {
		this.gp = gp;
	}
	
	public void checkTile(Entity entity) {
		int entityLeftX = entity.x + entity.solidArea.x;
		int entityRightX = entity.x + entity.solidArea.x + entity.solidArea.width;
		int entityTopY = entity.y + entity.solidArea.y;
		int entityBottomY = entity.y + entity.solidArea.y + entity.solidArea.height;
		
		int entityLeftCol = entityLeftX/gp.tileSize;
		int entityRightCol = entityRightX/gp.tileSize;
		int entityTopRow = entityTopY/gp.tileSize;
		int entityBottomRow = entityBottomY/gp.tileSize;
		
		int tileNum1, tileNum2;
		
		switch(entity.direction) {
		case "up" :
			entityTopRow = (entityTopY - entity.speed)/gp.tileSize;
			tileNum1 = gp.tileM.mapTileNum[entityLeftCol][entityTopRow];
			tileNum2 = gp.tileM.mapTileNum[entityRightCol][entityTopRow];
			if(gp.tileM.tile[tileNum1].collision == true || gp.tileM.tile[tileNum2].collision == true) {
				entity.collisionOn = true;
			}
			break;
		case "down" :
			entityBottomRow = (entityBottomY + entity.speed)/gp.tileSize;
			tileNum1 = gp.tileM.mapTileNum[entityLeftCol][entityBottomRow];
			tileNum2 = gp.tileM.mapTileNum[entityRightCol][entityBottomRow];
			if(gp.tileM.tile[tileNum1].collision == true || gp.tileM.tile[tileNum2].collision == true) {
				entity.collisionOn = true;
			}
			break;
		case "left" :
			entityLeftCol = (entityLeftX - entity.speed)/gp.tileSize;
			tileNum1 = gp.tileM.mapTileNum[entityLeftCol][entityTopRow];
			tileNum2 = gp.tileM.mapTileNum[entityLeftCol][entityBottomRow];
			if(gp.tileM.tile[tileNum1].collision == true || gp.tileM.tile[tileNum2].collision == true) {
				entity.collisionOn = true;
			}
			break;
		case "right" :
			entityRightCol = (entityRightX + entity.speed)/gp.tileSize;
			tileNum1 = gp.tileM.mapTileNum[entityRightCol][entityTopRow];
			tileNum2 = gp.tileM.mapTileNum[entityRightCol][entityBottomRow];
			if(gp.tileM.tile[tileNum1].collision == true || gp.tileM.tile[tileNum2].collision == true) {
				entity.collisionOn = true;
			}
			break;
		}
	}
    public int checkEntity(Entity entity, ArrayList<Entity> arrayEntity) {
    	int index = 0;
    	for(int i = 0 ; i < arrayEntity.size(); i++) {
    		if(arrayEntity.get(i) != null) {
    			int entityLeftX = arrayEntity.get(i).x + arrayEntity.get(i).solidArea.x;
    			int entityRightX = arrayEntity.get(i).x + arrayEntity.get(i).solidArea.x + arrayEntity.get(i).solidArea.width;
    			int entityTopY = arrayEntity.get(i).y + arrayEntity.get(i).solidArea.y;
    			int entityBottomY = arrayEntity.get(i).y + arrayEntity.get(i).solidArea.y + arrayEntity.get(i).solidArea.height;
    			
    			int entityLeftCol = entityLeftX/gp.tileSize;
    			int entityRightCol = entityRightX/gp.tileSize;
    			int entityTopRow = entityTopY/gp.tileSize;
    			int entityBottomRow = entityBottomY/gp.tileSize;
    			
    			int tileNum1, tileNum2;
    			
    			switch(arrayEntity.get(i).direction) {
    			case "up" :
    				entityTopRow = (entityTopY - arrayEntity.get(i).speed)/gp.tileSize;
    				tileNum1 = gp.tileM.mapTileNum[entityLeftCol][entityTopRow];
    				tileNum2 = gp.tileM.mapTileNum[entityRightCol][entityTopRow];
    				if(gp.tileM.tile[tileNum1].collision == true || gp.tileM.tile[tileNum2].collision == true) {
    					arrayEntity.get(i).collisionOn = true;
    					index = i;
    				}
    				break;
    			case "down" :
    				entityBottomRow = (entityBottomY + arrayEntity.get(i).speed)/gp.tileSize;
    				tileNum1 = gp.tileM.mapTileNum[entityLeftCol][entityBottomRow];
    				tileNum2 = gp.tileM.mapTileNum[entityRightCol][entityBottomRow];
    				if(gp.tileM.tile[tileNum1].collision == true || gp.tileM.tile[tileNum2].collision == true) {
    					arrayEntity.get(i).collisionOn = true;
    					index = i;
    				}
    				break;
    			case "left" :
    				entityLeftCol = (entityLeftX - arrayEntity.get(i).speed)/gp.tileSize;
    				tileNum1 = gp.tileM.mapTileNum[entityLeftCol][entityTopRow];
    				tileNum2 = gp.tileM.mapTileNum[entityLeftCol][entityBottomRow];
    				if(gp.tileM.tile[tileNum1].collision == true || gp.tileM.tile[tileNum2].collision == true) {
    					arrayEntity.get(i).collisionOn = true;
    					index = i;
    				}
    				break;
    			case "right" :
    				entityRightCol = (entityRightX + arrayEntity.get(i).speed)/gp.tileSize;
    				tileNum1 = gp.tileM.mapTileNum[entityRightCol][entityTopRow];
    				tileNum2 = gp.tileM.mapTileNum[entityRightCol][entityBottomRow];
    				if(gp.tileM.tile[tileNum1].collision == true || gp.tileM.tile[tileNum2].collision == true) {
    					arrayEntity.get(i).collisionOn = true;
    					index = i;
    				}
    				break;
    			}
    		}
    	}
    }
}
